using ExploitableApp.Data.DataAccess;
using ExploitableApp.Data.Managers;
using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace ExploitableApp.WebService.Services
{
    public class RandomTransactionService : IHostedService
    {
        private bool _shouldStop = false;
        private readonly IServiceScopeFactory _scopeFactory;
        private readonly IConfiguration _configuration;
        private readonly List<HubConnection> _connections = new List<HubConnection>();
        private Task task;
        public RandomTransactionService(IConfiguration configuration, IServiceScopeFactory scopeFactory)
        {
            _scopeFactory = scopeFactory;
            _configuration = configuration;
            if (!string.IsNullOrEmpty(Environment.GetEnvironmentVariable("WEBSERVER_SERVICE_ENDPOINT")))
            {
                var url = Environment.GetEnvironmentVariable("WEBSERVER_SERVICE_ENDPOINT").TrimEnd('/').TrimEnd('\\') + "/transactionhub";
                var hc = new HubConnectionBuilder()
                    .WithUrl(url)
                    .ConfigureLogging(x => { x.AddConsole().AddDebug(); })
                    .Build();

                hc.StartAsync();
                _connections.Add(hc);
            }
            else
            {
                configuration.GetSection("KnownWebServers")["URLS"].Split(',').ToList().ForEach(url =>
                {
                    var hc = new HubConnectionBuilder()
                    .WithUrl(url)
                    .ConfigureLogging(x => { x.AddConsole().AddDebug(); })
                    .Build();

                    hc.StartAsync();
                    _connections.Add(hc);
                });
            }
        }

        public Task StartAsync(CancellationToken cancellationToken)
        {
            _shouldStop = false;
            task = new Task(() =>
            {
                var r = new Random(12345);
                while (!_shouldStop)
                {
                    Thread.Sleep((int)Math.Ceiling(r.NextDouble() * 60 * 1000));
                    Console.WriteLine("RandomTransactionService Running");
                    using (var scope = _scopeFactory.CreateScope())
                    {
                        var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
                        var accounts = dbContext.BankingAccounts.OrderBy(x => Guid.NewGuid()).Take(2).ToArray();
                        var mgr = new BankingAccountManager(_configuration);
                        var t = mgr.CreateTransaction(accounts[0], accounts[1], (float)(r.NextDouble() * (0.05 * accounts[0].Balance)), $"Payment from {accounts[0].ID} to {accounts[1].ID}", DateTime.Now, true);
                        t = mgr.CompleteTransaction(t);
                        var data = new
                        {
                            t.ID,
                            t.Status,
                            t.Time,
                            t.Amount,
                            t.Description,
                            From = new
                            {
                                t.From.ID
                            },
                            To = new
                            {
                                t.To.ID
                            }
                        };
                        _connections.ForEach(hc =>
                        {
                            hc.InvokeAsync("SendTransactionNotification", data);
                        });
                        Console.WriteLine($"RandomTransactionService Completed Transaction:{Environment.NewLine}{JsonConvert.SerializeObject(data)}");
                    }
                }
            }, cancellationToken);
            task.Start();
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            _shouldStop = true;
            return Task.CompletedTask;
        }
    }
}
