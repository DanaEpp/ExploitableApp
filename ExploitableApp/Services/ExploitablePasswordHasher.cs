using System;
using System.Security.Cryptography;
using System.Text;
using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Configuration;

namespace ExploitableApp.Services
{
    /*
     * If you are looking at this Password Hasher and thinking, that looks pretty secure to me, 
     * then you need to have a look at Hashcat and consider that the passwords used to create these
     * fake users are all previously leaked & hashed passwords which have been cracked using the Hashcat
     * GPU password cracker.
     * 
     * https://github.com/hashcat/hashcat
     * 
     */
    public class ExploitablePasswordHasher<T> : IPasswordHasher<T> where T : class
    {
        private const string WEAK_SALT =  "exploitableapp"; //<-- who would have ever guessed that...
        public string HashPassword(string password)
        {
            password = WEAK_SALT + password;
            using (SHA1 sha = SHA1.Create())
            {
                byte[] hash = sha.ComputeHash(Encoding.UTF8.GetBytes(password.ToString()));

                StringBuilder hashSB = new StringBuilder();
                for (int i = 0; i < hash.Length; i++)
                {
                    hashSB.Append(hash[i].ToString("x2"));
                }
                return hashSB.ToString();
            }
        }

        public string HashPassword(T user, string password)
        {
            return HashPassword(password);
        }

        public PasswordVerificationResult VerifyHashedPassword(
          string hashedPassword, string providedPassword)
        {
            if (hashedPassword == HashPassword(providedPassword))
                return PasswordVerificationResult.Success;
            else
                return PasswordVerificationResult.Failed;
        }

        public PasswordVerificationResult VerifyHashedPassword(T user, string hashedPassword, string providedPassword)
        {
            return VerifyHashedPassword(hashedPassword, providedPassword);
        }
    }

}
