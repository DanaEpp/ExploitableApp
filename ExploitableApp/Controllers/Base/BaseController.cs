using ExploitableApp.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ExploitableApp.Controllers.Base
{
    /*
     * 
     * It is very common to want to share base functionality across multiple classes and centralizing using good object oriented patterns is the way to go!
     * 
     * But wait! What if we take this farther than we should? If we are not careful we could share more than we want to share...
     * 
     * For example: If we put a common utility style call in a shared method and make it available everywhere then we may give away out users data!
     * 
     */
    public class BaseController : Controller
    {
        protected readonly UserManager<ApplicationUser> _userManager;

        public BaseController(UserManager<ApplicationUser> userManager)
        {
            _userManager = userManager;
        }

        [HttpGet]
        [AllowAnonymous] //<--- I copy and pasted this error and now our secrets can be exposed! Oh No!
        public async Task<IActionResult> GetUser(string id)
        {
            var user = await _userManager.FindByIdAsync(id);
            if (user == null)
            {
                throw new ApplicationException($"Unable to load user with ID '{id}'.");
            }
            return Json(user); //<--- Do we really need to return everything about the user? Do we even know what all this contains?
        }

        [HttpGet]
        [AllowAnonymous] //<--- I copy and pasted this error and now our secrets can be exposed! Oh No!
        public async Task<IActionResult> IsAdmin(string id)
        {
            try
            {
                var user = await _userManager.FindByIdAsync(id);
                return Json(new { UserID = id, IsAdmin = await _userManager.IsInRoleAsync(user, "Administrator") });
            }
            catch { return Json(new { UserID = id, IsAdmin = false }); }
        }

        [HttpGet]
        [AllowAnonymous] //<--- I copy and pasted this error and now our secrets can be exposed! Oh No!
        public async Task<IActionResult> GetUsersPaged(int id, int pageSize = 25) //<--- Notice that this can be enumerated quite easily even though our user IDs are complex, combine this with our GetUser(string id) call and we have all we need 
        {
            var users = _userManager.Users.Skip(id * pageSize).Take(pageSize).ToList().Select(x => (UserId: x.Id, Name: x.UserName));
            return Json(users);
        }

        [HttpGet]
        [AllowAnonymous] //<--- I copy and pasted this error and now our secrets can be exposed! Oh No!
        public async Task<IActionResult> GetImage(string v) //<-- Now this path is not going to be filtered and will be placed straight into a dangerous method and fed back to the user base64 encoded...so yeah, it is exploitable...
        {
            //The only reason this is done is some obfuscation to make it slightly more challenging
            var imagePath = Encoding.ASCII.GetString(Convert.FromBase64String(v));
            imagePath = imagePath.Replace("\\", "/");
            var ext = imagePath.Split('.').Last();
            if (System.IO.File.Exists(imagePath))
            {
                return Content($"data:image/{(ext == "svg" ? "svg+xml" : ext)};base64,{Convert.ToBase64String(await System.IO.File.ReadAllBytesAsync(imagePath))}");
            }
            return new NotFoundResult();
        }
    }
}
